#!/bin/bash

# Global Setting {{{1
# Use other trigger instead of default **
#export FZF_COMPLETION_TRIGGER="'"

#NOTE: this determines also search program for fzf.vim
#now fzf (w/o pipe) will use ag instead of find
if type ag &> /dev/null; then
    export FZF_DEFAULT_COMMAND='ag -g ""'
fi

#refer rg over ag
if type rg &> /dev/null; then
    export FZF_DEFAULT_COMMAND='rg --files --hidden'
fi

#show matches in top-down order
export FZF_DEFAULT_OPTS="--reverse \
                         --bind='ctrl-h:half-page-down,ctrl-l:half-page-up'"

#working directory with tree preview
if type tree &> /dev/null; then
    export FZF_ALT_C_OPTS="--preview 'tree -C {} | head -100'"
fi
#1}}}


###############################################################################################
#Files and Folders {{{1

#fuzzy history
#   show bash_history w/o duplicates and order preserved
#   overwrite default keybind c-r
fh() {
    local revshist # return history in reverse order
    if [[ $OSTYPE == "darwin"* ]]; then
        revshist="tail -r $HISTFILE"
    else
       revshist="tac $HISTFILE"
    fi

    eval $revshist | awk '!x[$0]++' |
    fzf --prompt='(history search): ' --query="$*" --cycle --exact --select-1 --no-sort --height 10%
}
bind '"\er": redraw-current-line'
bind '"\C-r": "$(fh)\e\C-e\er"'

#jump to bookmark of autojump
fj() {
    local dir=$(autojump --stat | sed '/___/,$d' | cut -f 2 |   #use only second column
                sed '/rvm\/copy/d' |                            #ignore rvm_copy
                fzf --query="$1" --select-1 --tac --no-sort --height 10%)
    [ -d "$dir" ] && cd "$dir"
}

#cd directory
fd() {
    local dir=$(find ${1:-.} -path '*/\.*' -prune -o -type d -not -path "*/build*/*" -print 2> /dev/null |
        fzf +m --preview-window=right --preview="tree {} -L 3 -C | head -100") &&
        cd "$dir" && ls -l
}

#open the selected file with the default editor (prefer vim)
fe() {
    local files
    #for fast processing pipe only 300 headline of file
    #highlight with ansi output format and line number
    #also force output when filetype not recognized, mute error in case not a file
    IFS=$'\n' files=($(fzf --query="$1" --multi --select-1 --exit-0 \
                        --preview="head -300 {} | highlight -O ansi -l --force 2>/dev/null"))
    #TODO ctrl-t:open files in tabs, ctrl-w: open files in windows
    [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}
#1}}}


###############################################################################################
# git stuff {{{1

gitcheckout() {
    local list response key branch header
    list=$(git branch --all --color -vv; git tag) || return 1
    mapfile -t response < <(fzf --query=$1 --prompt='checkout: ' \
        --ansi --header="$header" --expect=ctrl-x <<< "$list")
    key="${response[0]}"
    branch=$(perl -pe 's/^\*?\s*(remotes\/[^\/]*\/)?([^ ]+).*/\2/' <<< "${response[1]}")
    git checkout "$branch" || return 1
}

# a git commit browser
#   ctrl-w: show preview window
#   enter:  open commit diff
#   ctrl-c: exit
gitlog() {
    local pos   #position of preview window
    [ $(tput cols) -ge 200 ] && pos="right" || pos="down"
    local cmdshow="git show --color=always \"\$(grep -m1 -o '[a-f0-9]\{7\}' <<< {} | head -1 )\""
    fzf --ansi -e --no-sort --tiebreak=index \
        --bind="ctrl-h:page-down,ctrl-l:page-up,ctrl-w:toggle-preview,enter:execute($cmdshow | less -R)" \
        --preview-window="$pos":hidden:wrap --preview="$cmdshow" \
        < <(git log --graph --color=always --format="%C(auto)%h%d %s %Cgreen(%cr) %Creset<%an>" "$@")
    return 0;
}

#TODO open in vim instead
gitstatus() {
    local cmddiff="git diff --color=always "$@""
    git status -sb | sed '/##/d' |
    fzf --ansi --no-sort \
        --preview-window=right:70%:wrap --preview="$cmddiff {2}" \
        --bind="enter:execute($cmddiff {2} | less -R)" \
        --bind="ctrl-o:execute(gvim --remote-silent {2})" \
        --bind="j:down,k:up"
    return 0;
}

# stash list show
gitstash() {
    local out key idx
    stashlist=$(git stash list --pretty='%C(yellow)%gd %>(14)%Cgreen%cr %C(blue)%gs')
    [ -z "$stashlist" ] && return
    out=($(fzf --ansi --no-sort \
        --header='enter:show, ctrl-d:diff, ctrl-o:pop, ctrl-y:apply, ctrl-x:drop' \
        --preview='git stash show --color=always -p $(cut -d" " -f1 <<< {}) | head -'$LINES \
        --preview-window=down:80% --reverse \
        --bind='enter:execute(git stash show --color=always -p $(cut -d" " -f1 <<< {}) | less -r > /dev/tty)' \
        --bind='ctrl-d:execute(git diff --color=always $(cut -d" " -f1 <<< {}) | less -r > /dev/tty)' \
        --expect=ctrl-o,ctrl-y,ctrl-x <<< "$stashlist"))
    #fzf returns key (first) result (second) if 'expect' specified (without --print-query)
    key=${out[0]}
    idx=${out[1]}
    [ -n "$idx" ] && case "$key" in
        ctrl-o) git stash pop $idx ;;
        ctrl-x) git stash drop $idx ;;
        ctrl-y) git stash apply $idx ;;
    esac
}

#1}}}


###############################################################################################
#other commands {{{1

#kill tmux session
tkill() {
    [ ! type tmux &> /dev/null ] && return
    #select from session list with fzf
    #remove everything after ':' before return session names
    local sessions=( $(tmux list-session | fzf -m | sed 's/: .*//') )
    for elem in ${sessions[@]}; do
        tmux kill-session -t "$elem" && echo "killed session: '$elem'"
    done
}
#1}}}

# vim:foldmethod=marker:foldlevel=1
